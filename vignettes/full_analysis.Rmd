---
title: "Analyzing High Density Peptide Array Data using HERON"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{Analyzing High Density Peptide Array Data using HERON}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# HERON

<!-- badges: start -->
<!-- badges: end -->

The goal of HERON (**H**ierarchical **E**pitope p**RO**tein bi**N**ding) is to
analyze peptide binding array data measured from nimblegen or any high density
peptide binding array data.

## Installation

You can install the released version of HERON from 
[bioconductor](https://www.bioconductor.org/) with:

``` r
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

# The following initializes usage of Bioc devel
BiocManager::install(version='devel')

BiocManager::install("HERON")
```

And the development version from 
[GitHub](https://github.com/Ong-Research/HERON) with:

``` r
# install.packages("devtools")
devtools::install_github("Ong-Research/HERON")
```


```{r setup}
library(HERON)
```

## Example

These are examples which shows you how to interact with the code.  We will be
using a subset of the COVID-19 peptide binding array dataset from the 
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8245122/ publication.

### Pre-process data

The data is pre-processed by first quantile normalizing on sequence-level data.


```{r, example_process_data}
data(heffron2020_wuhan)

## Quantile normalize
seq_mat_qn <- quantileNormalize(heffron2020_wuhan)

knitr::kable(head(seq_mat_qn[,1:5]))
```

### Calculate probe-level p-values

The quantile normalized data is then used with the pData and probe_meta
data frames to calculate probe-level p-values.  The pData data frame
describes the experimental setup of the samples.  for the pData data frame,
the important columns are TOOD

```{r example_pData}
pData <- attr(heffron2020_wuhan, "pData")
knitr::kable(head(pData))
```

The probe_meta data frame describes the mapping the amino acid sequence 
(PROBE_SEQUENCE) of the probes to the probe identifier (PROBE_ID).  The
PROBE_ID contains the name of the protein and the position within the
protein of the first acid of the probe sequence. 

```{r example_probe_meta}
probe_meta <- attr(heffron2020_wuhan, "probe_meta")
knitr::kable(head(probe_meta[,c("PROBE_SEQUENCE", "PROBE_ID")]))
```
The *calcProbePValuesSeqMat* call will first calculate the probe level
p-values using the pData data frame, adjust the probe p-values on a 
column-by-column basis frame, and then use the probe_meta data frame
to map the p-values to the probe identifiers, also adjusts the
probe p-values sample-by-sample.

```{r example_probe_pvalues}

probe_pval_res <- calcProbePValuesSeqMat(seq_mat_qn, probe_meta, pData)
knitr::kable(head(probe_pval_res[,1:5]))

```

### Obtain probe-level calls

Once the p-values have been calculated, the *makeProbeCalls* will make the
calls using the adjusted p-values calculated.  *makeProbeCalls* also includes
a filter to remove one-hit probes, which are probes that were called only
in one sample and do not have a consecutive probe called in a single sample.
The return value is a list, which provides two main matrices.  One for the
sample level calls and another for the k-of-n calls.

```{r, example_probe_calls}

probe_calls_res <- makeProbeCalls(probe_pval_res)

knitr::kable(head(probe_calls_res$sample[,1:5]))

knitr::kable(head(probe_calls_res$k_of_n[,1:5]))


```

### Find Epitope Segments using the unique method

After calculating probe p-values and calls, the HERON can find epitope segments,
i.e. blocks of consecutive probes that have been called within a sample or
cluster of samples.  The unique method finds all consective probes for
each sample, then returns the unique set of all epitopic regions.


```{r, example_epitope_finding_unique}

epi_segments_uniq_res <- findEpitopeSegments(
    probe_calls = probe_calls_res,
    segment.method = "unique"
);

knitr::kable(head(epi_segments_uniq_res))

```

The format of the epitope segments are SEQ_ID_Begin_End, where
the begin is the starting position of the first probe within the
consecutive block, and the End is the starting position of the last
probe within the consecutive block.

### Calculate Epitope-level p-values

With the epitope segments and the probe p-values, HERON can calculate a 
significance value for the segments using a meta p-value method.  Here,
we are calculating epitope p-values using Wilkinson's max meta p-value method.

```{r, example_epitope_pvalues}
epi_pval_uniq <- calcEpitopePValuesMat(
    probe_pvalues = attr(probe_pval_res, "pvalue"), 
    epitope_ids = epi_segments_uniq_res, 
    method = "wilkinsons_max1"
)
```
We can then adjust the epitope p-values using *p_adjust_mat*.
```{r}
epi_padj_uniq <- p_adjust_mat(epi_pval_uniq, method="BH")
```

### Obtain Epitope-level calls

The makeCalls method will work on the epitope adjusted p-values to make
epitope-level sample and k-of-n calls.

```{r, example_epitope_calls}

epi_calls_uniq <- makeCalls(epi_padj_uniq)

```

### Calculate Protein-level p-values

Calculate protein p-values using Tippet's (Wilkinson's Min) meta p-value method.

```{r, example_protein_pvalues}
prot_pval_uniq <- calcProteinPValuesMat(epi_pval_uniq, method = "tippets");
prot_padj_uniq <- p_adjust_mat(prot_pval_uniq, method = "BH")

```

### Obtain Protein-level calls

```{r, example_protein_calls}
prot_calls_uniq <- makeCalls(prot_padj_uniq)
```

## Other 

The are other functions to utilize depending upon what you would like to do.
For example, there are different methods for finding the epitope
segments that involve clustering across samples.  There are two main
methods, one using hierarchical clustering and another using
the *skater* method from the *spdep* package.  In addition to the
two methods, how the distance matrix is calculated can be modified.  The
following subsections demonstrate how to find epitope segment blocks using
*hclust* or *skater* and using a binary hamming distance or a numeric
euclidean distance for making calls.  After the segments are found, you can
then use the *calcEpitopePValuesMat* and *makeCalls* functions as before to
find the epitope p-values, protein p-values, and the respective calls. 

### Find Epitope Segments using the hclust method

#### binary calls with hamming distance

```{r, example_epitope_finding_hclust}
epi_segments_hclust_res <- findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "hclust",
    segment.score.type = "binary",
    segment.dist.method = "hamming",
    segment.cutoff = "silhouette");
```

#### z-scores with euclidean distance

```{r, example_epitope_finding_hclust2}
epi_segments_hclust_res2 <- findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "hclust",
    segment.score.type = "zscore",
    segment.dist.method = "euclidean",
    segment.cutoff = "silhouette");
```



### Find Epitope Segments using the skater method

#### binary calls with hamming distance


```{r, example_epitope_finding_skater}
epi_segments_skater_res <- findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "skater",
    segment.score.type = "binary",
    segment.dist.method = "hamming",
    segment.cutoff = "silhouette");
```

#### z-scores with euclidean distance

```{r, example_epitope_finding_skater2}
epi_segments_skater_res <- findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "skater",
    segment.score.type = "zscore",
    segment.dist.method = "euclidean",
    segment.cutoff = "silhouette");
```


## Making z-score cutoff calls

Some investigators would like to make z-score level calls global rather then
using adjusted p-values.  HERON is flexible to allow for such a setup.
For example, the user wanted to make probe-level calls using a 
z-score cutoff > 2.  

```{r}

probe_pval_res_z <- calcProbePValuesSeqMat(
    seq_mat_qn, 
    probe_meta, 
    pData, 
    use = "z", 
    p.adjust.method = "none")

p_cutoff = pnorm(2, lower.tail = FALSE)

probe_calls_z2 <- makeProbeCalls(probe_pval_res_z, probe_cutoff = p_cutoff)

knitr::kable(head(probe_calls_z2$sample[,1:5]))

knitr::kable(head(probe_calls_z2$k_of_n[,1:5]))

```

The calls can also be used to find epitopes segments, p-values, and calls.
Also, can be used to make protein level calls.

```{r}
epi_segments_uniq_z2_res <- findEpitopeSegments(
    probe_calls = probe_calls_z2,
    segment.method = "unique"
);
```

If we want to find regions where the z > 2 for all of the consecutive probes,
using the *maxFDR* meta p-value method will ensure that.

```{r}

epi_pval_uniq_z2 <- calcEpitopePValuesMat(
    probe_pvalues = probe_pval_res_z, 
    epitope_ids = epi_segments_uniq_z2_res, 
    method = "maxFDR"
)
```

Again, *makeCalls* will be used in order to find significant regions.

```{r}
epi_calls_uniq_z2 <- makeCalls(epi_pval_uniq_z2, padj_cutoff = p_cutoff)
```

Other segmentation methods can be used with the called regions through the
binary score clustering methods.

```{r}
epi_segments_skater_z2_res <- findEpitopeSegments(
    probe_pval_res_z, 
    probe_calls_z2,
    segment.method = "skater",
    segment.score.type = "binary",
    segment.dist.method = "hamming",
    segment.cutoff = "silhouette");
```

## Smoothing across probes

The pepStat paper [REF] mentions that smoothing can sometimes help reduce
the high-variability of the peptide array data.  HERON has implemented a
running average smoothing algorithm across protein probes that can handle
missing values. The function *smoothProbeMat* will take as input a probe
matrix and will return a matrix that has been smoothed.  The smoothed
matrix can then be processed through the workflow using the
*calcProbePValuesProbeMat* call instead of the *calcProbePValuesSeqMat*
call since now the probe signal is no longer a direct copy from the sequence.


```{r}
probe_mat = convertSequenceMatToProbeMat(seq_mat_qn, probe_meta)
smooth_mat <- smoothProbeMat(probe_mat)
```

After you smoothed the data using the probes, the probe p-value need to be
calculated on the probe-level rather than the sequence level.

```{r}
probe_sm_pval = calcProbePValuesProbeMat(smooth_mat, pData);
```

The probe calls can then be made as before.

```{r}
probe_sm_calls = makeProbeCalls(probe_sm_pval)

knitr::kable(probe_sm_calls$sample[1:3,1:3])
knitr::kable(probe_sm_calls$k_of_n[1:3,1:3])
```

## Funding

HERON and its developers have been partially supported by funding from the 
Clinical and Translational Science Award (CTSA) program (ncats.nih.gov/ctsa), 
through the National Institutes of Health National Center for Advancing 
Translational Sciences (NCATS), grants UL1TR002373 and KL2TR002374, NIH National
Institute of Allergy and Infectious Diseases, 2U19AI104317-06, NIH National
Cancer Institute and University of Wisconsin Carbone Comprehensive Cancer 
Center’s Cancer Informatics Shared Resource (grant P30-CA-14520), startup funds
through the University of Wisconsin Department of Obstetrics and Gynecology and
the University of Wisconsin-Madison Office of the Chancellor and the Vice
Chancellor for Research and Graduate Education with funding from the Wisconsin 
Alumni Research Foundation through the Data Science Initiative award.

## Acknowledgments

We have benefited in the development of *HERON* from the help and
feedback of many individuals, including but not limited to: 

The Bioconductor Core Team,
Paul Sondel, 
Anna Hoefges, 
Amy Erbe Gurel, 
Jessica Vera,
Rene Welch,
Ken Lo (Nimble Therapeutics),
Brad Garcia (Nimble Therapeutics),
Jigar Patel (Nimble Therapeutics),
John Tan,
Richard Pinapatti.

# Session Info

```{r, session_info}
sessionInfo()
```




