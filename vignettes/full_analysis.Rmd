---
title: "Analysis of High Density Peptide Array Data using HERON"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analysis of High Density Peptide Array Data using HERON}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# HERON

<!-- badges: start -->
<!-- badges: end -->

The goal of HERON (**H**ierarchical **E**pitope p**RO**tein bi**N**ding) is to
analyze peptide binding array data measured from nimblegen or any high density
peptide binding microarray data.

## Installation

You can install the released version of HERON from 
[github](https://github.com/Ong-Research/HERON) with:

``` r
devtools::install_github("Ong-Research/HERON")
```

And the development version from 
[GitHub](https://github.com/Ong-Research/HERON) with:

``` r
# install.packages("devtools")
devtools::install_github("Ong-Research/HERON")
```


```{r setup}
library(HERON)
```

## Example

These are examples which shows you how to interact with the code.  We will be
using the COVID-19 peptide binding array dataset from the 
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8245122/ publication.


### Pre-process data


```{r, example_process_data}
data(heffron2020_wuhan)

## Quantile normalize
seq_mat_qn = quantileNormalize(heffron2020_wuhan)
probe_meta = attr(heffron2020_wuhan, "probe_meta")
sample_meta = attr(heffron2020_wuhan, "sample_meta")

## Create pData data.frame
create_pData<-function(mat_in) {
  
  
  pData = data.frame(
    Sample_ID = colnames(mat_in),
    ptid = colnames(mat_in),
    visit = "pre",
    condition = "Control",
    stringsAsFactors=FALSE
  );
  pos_samples = sample_meta$SAMPLE_NAME[sample_meta$COVID_POSITIVE == "YES"]
  pData$condition[pData$Sample_ID %in% pos_samples] = "COVID";
  pData$visit[pData$condition == "COVID"] = "post"
  pData$TAG = pData$Sample_ID;
  
  return(pData);
}

pData = create_pData(seq_mat_qn)

knitr::kable(head(pData));

```

### Calculate probe-level p-values

```{r example_probe_pvalues}

probe_pval_res <- calcProbePValuesSeqMat(seq_mat_qn, probe_meta, pData)

```

### Obtain probe-level calls

```{r, example_probe_calls}

probe_calls_res <- makeProbeCalls(probe_pval_res)

```

### Find Epitope Segments using the unique method

```{r, example_epitope_finding_unique}

epi_segments_uniq_res = findEpitopeSegments(
    probe_calls = probe_calls_res,
    segment.method = "unique"
);

```

### Calculate Epitope-level p-values


Calculate epitope p-values using Wilkinson's max meta p-value method. 
```{r, example_epitope_pvalues}
epi_pval_uniq <- calcEpitopePValuesMat(
    probe_pvalues = attr(probe_pval_res, "pvalue"), 
    epitope_ids = epi_segments_uniq_res, 
    method = "wilkinsons_max1"
)

epi_padj_uniq <- p_adjust_mat(epi_pval_uniq, method="BH")

```

### Obtain Epitope-level calls

The makeCalls method will work on the epitope adjusted p-values 

```{r, example_epitope_calls}

epi_calls_uniq <- makeCalls(epi_padj_uniq)

```

### Calculate Protein-level p-values

Calculate protein p-values using Tippet's (Wilkinson's Min) meta p-value method.

```{r, example_protein_pvalues}
prot_pval_uniq = calcProteinPValuesMat(epi_pval_uniq, method = "tippets");
prot_padj_uniq = p_adjust_mat(prot_pval_uniq, method = "BH")

```

### Obtain Protein-level calls

```{r, example_protein_calls}
prot_calls_uniq <- makeCalls(prot_padj_uniq)
```

### Find Eptope Segments using the hclust method

#### binary calls with hamming distance

```{r, example_epitope_finding_hclust}
epi_segments_hclust_res = findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "hclust",
    segment.score.type = "binary",
    segment.dist.method = "hamming",
    segment.cutoff = "silhouette");
```

#### z-scores with euclidean distance

```{r, example_epitope_finding_hclust2}
epi_segments_hclust_res2 = findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "hclust",
    segment.score.type = "zscore",
    segment.dist.method = "euclidean",
    segment.cutoff = "silhouette");
```



### Find Epitope Segments using the skater method

#### binary calls with hamming distance


```{r, example_epitope_finding_skater}
epi_segments_skater_res = findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "skater",
    segment.score.type = "binary",
    segment.dist.method = "hamming",
    segment.cutoff = "silhouette");
```

#### z-scores with euclidean distance

```{r, example_epitope_finding_skater2}
epi_segments_skater_res = findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "skater",
    segment.score.type = "zscore",
    segment.dist.method = "euclidean",
    segment.cutoff = "silhouette");
```



End of Vignette




