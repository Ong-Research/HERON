---
title: "Analyzing High Density Peptide Array Data using HERON"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{Analyzing High Density Peptide Array Data using HERON}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# HERON

<!-- badges: start -->
<!-- badges: end -->

The goal of HERON (**H**ierarchical **E**pitope p**RO**tein bi**N**ding) is to
analyze peptide binding array data measured from nimblegen or any high density
peptide binding array data.

## Installation

You can install the released version of HERON from [bioconductor](https://www.bioconductor.org/) with:

``` r
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

# The following initializes usage of Bioc devel
BiocManager::install(version='devel')

BiocManager::install("HERON")
```

And the development version from [GitHub](https://github.com/Ong-Research/HERON) with:

``` r
# install.packages("devtools")
devtools::install_github("Ong-Research/HERON")
```


```{r setup}
library(HERON)
```

## Example

These are examples which shows you how to interact with the code.  We will be
using a subset of the COVID-19 peptide binding array dataset from the 
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8245122/ publication.

### Pre-process data

The data is pre-processed by first quantile normalizing on sequence-level data.


```{r, example_process_data}
data(heffron2020_wuhan)

## Quantile normalize
seq_mat_qn <- quantileNormalize(heffron2020_wuhan)

knitr::kable(head(seq_mat_qn[,1:5]))
```

### Calculate probe-level p-values

The quantile normalized data is then used with the pData and probe_meta
data frames to calculate probe-level p-values.  The pData data frame
describes the experimental setup of the samples.  

```{r example_pData}
pData <- attr(heffron2020_wuhan, "pData")
knitr::kable(head(pData))
```

The probe_meta data frame describes the mapping the amino acid sequence 
(PROBE_SEQUENCE) of the probes to the probe identifier (PROBE_ID).  The
PROBE_ID contains the name of the protein and the position within the
protein of the first acid of the probe sequence. 

```{r example_probe_meta}
probe_meta <- attr(heffron2020_wuhan, "probe_meta")
knitr::kable(head(probe_meta[,c("PROBE_SEQUENCE", "PROBE_ID")]))
```
The *calcProbePValuesSeqMat* call will first calculate the probe level
p-values using the pData data frame, adjust the probe p-values on a 
column-by-column basis frame, and then use the probe_meta data frame
to map the p-values to the probe identifiers, also adjusts the
probe p-values sample-by-sample.

```{r example_probe_pvalues}

probe_pval_res <- calcProbePValuesSeqMat(seq_mat_qn, probe_meta, pData)
knitr::kable(head(probe_pval_res[,1:5]))

```

### Obtain probe-level calls

Once the p-values have been calculated, the *makeProbeCalls* will make the
calls using the adjusted p-values calculated.  *makeProbeCalls* also includes
a filter to remove one-hit probes, which are probes that were called only
in one sample and do not have a consecutive probe called in a single sample.
The return value is a list, which provides two main matrices.  One for the
sample level calls and another for the k-of-n calls.

```{r, example_probe_calls}

probe_calls_res <- makeProbeCalls(probe_pval_res)

knitr::kable(head(probe_calls_res$sample[,1:5]))

knitr::kable(head(probe_calls_res$k_of_n[,1:5]))


```

### Find Epitope Segments using the unique method

```{r, example_epitope_finding_unique}

epi_segments_uniq_res = findEpitopeSegments(
    probe_calls = probe_calls_res,
    segment.method = "unique"
);

```

### Calculate Epitope-level p-values


Calculate epitope p-values using Wilkinson's max meta p-value method. 
```{r, example_epitope_pvalues}
epi_pval_uniq <- calcEpitopePValuesMat(
    probe_pvalues = attr(probe_pval_res, "pvalue"), 
    epitope_ids = epi_segments_uniq_res, 
    method = "wilkinsons_max1"
)

epi_padj_uniq <- p_adjust_mat(epi_pval_uniq, method="BH")

```

### Obtain Epitope-level calls

The makeCalls method will work on the epitope adjusted p-values 

```{r, example_epitope_calls}

epi_calls_uniq <- makeCalls(epi_padj_uniq)

```

### Calculate Protein-level p-values

Calculate protein p-values using Tippet's (Wilkinson's Min) meta p-value method.

```{r, example_protein_pvalues}
prot_pval_uniq = calcProteinPValuesMat(epi_pval_uniq, method = "tippets");
prot_padj_uniq = p_adjust_mat(prot_pval_uniq, method = "BH")

```

### Obtain Protein-level calls

```{r, example_protein_calls}
prot_calls_uniq <- makeCalls(prot_padj_uniq)
```

### Find Eptope Segments using the hclust method

#### binary calls with hamming distance

```{r, example_epitope_finding_hclust}
epi_segments_hclust_res = findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "hclust",
    segment.score.type = "binary",
    segment.dist.method = "hamming",
    segment.cutoff = "silhouette");
```

#### z-scores with euclidean distance

```{r, example_epitope_finding_hclust2}
epi_segments_hclust_res2 = findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "hclust",
    segment.score.type = "zscore",
    segment.dist.method = "euclidean",
    segment.cutoff = "silhouette");
```



### Find Epitope Segments using the skater method

#### binary calls with hamming distance


```{r, example_epitope_finding_skater}
epi_segments_skater_res = findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "skater",
    segment.score.type = "binary",
    segment.dist.method = "hamming",
    segment.cutoff = "silhouette");
```

#### z-scores with euclidean distance

```{r, example_epitope_finding_skater2}
epi_segments_skater_res = findEpitopeSegments(
    probe_pval_res, 
    probe_calls_res,
    segment.method = "skater",
    segment.score.type = "zscore",
    segment.dist.method = "euclidean",
    segment.cutoff = "silhouette");
```

# Session Info

```{r, session_info}
sessionInfo()
```




